// GENERATED CODE - DO NOT MODIFY BY HAND
// This file was generated by shelf_rpc.
// ignore_for_file: non_constant_identifier_names, unused_local_variable, implementation_imports, no_leading_underscores_for_local_identifiers, prefer_null_aware_operators

import 'dart:convert';
import 'package:shelf/shelf.dart';
import 'package:globe_functions/src/shelf_rpc.dart';
import 'package:globe_functions/src/spec/serializer.dart';
import 'package:globe_functions/src/server/request_params.dart';
import 'package:globe_functions/src/server/request_context.dart';
import 'package:globe_functions/src/server/sse_response.dart';
import 'package:functions/models.dart' as i0;
import 'package:functions/rpc.dart' as i1;

final api = Pipeline().addHandler((Request request) async {
  final params = await RequestParams.fromRequest(request);
  final positional = params.positional;
  final named = params.named;
  final _api = i1.api;
  Pipeline pipeline = Pipeline();

  for (final m in _api.middleware) {
    pipeline = pipeline.addMiddleware(m);
  }

  switch (params.id) {
    case "params":
      final procedure = _api.routes[#params] as ExecutedProcedure;
      final middleware = procedure.middleware;

      for (final m in middleware) {
        pipeline = pipeline.addMiddleware(m);
      }

      return pipeline.addHandler((request) async {
        final fn =
            procedure.fn
                as String Function(
                  i0.User? user, {
                  int? age,
                  String? email,
                  Map<String, String?>? meta,
                  required String name,
                });
        final ctx = RequestContext();
        final p0 =
            positional[0] = i0.User?.fromJson(
              positional[0] as Map<String, dynamic>,
            );
        final n0 =
            named["age"] == null
                ? null
                : Serializers.instance.get<int>().deserialize(named["age"]);
        final n1 =
            named["email"] == null
                ? null
                : Serializers.instance.get<String>().deserialize(
                  named["email"],
                );
        final n2 =
            named["meta"] == null
                ? null
                : Serializers.instance.get<Map<String, String>>().deserialize(
                  named["meta"],
                );
        final n3 =
            named["name"] = Serializers.instance.get<String>().deserialize(
              named["name"],
            );
        final result = fn(
          p0,
          age: n0 ?? 10,
          email: n1 ?? 'test@test.com',
          meta: n2 ?? const {},
          name: n3,
        );
        final serialized = Serializers.instance.get<String>().serialize(result);
        return Response.ok(jsonEncode({"result": serialized}));
      })(request);
    case "nested.sub1":
      final _nested = _api.routes[#nested] as Router;
      final procedure = _nested.routes[#sub1] as ExecutedProcedure;
      final middleware = procedure.middleware;

      for (final m in middleware) {
        pipeline = pipeline.addMiddleware(m);
      }

      return pipeline.addHandler((request) async {
        final fn = procedure.fn as String Function();
        final ctx = RequestContext();

        final result = fn();
        final serialized = Serializers.instance.get<String>().serialize(result);
        return Response.ok(jsonEncode({"result": serialized}));
      })(request);
    case "nested.sub2.sub3":
      final _nested = _api.routes[#nested] as Router;
      final _nested_sub2 = _nested.routes[#sub2] as Router;
      final procedure = _nested_sub2.routes[#sub3] as ExecutedProcedure;
      final middleware = procedure.middleware;

      for (final m in middleware) {
        pipeline = pipeline.addMiddleware(m);
      }

      return pipeline.addHandler((request) async {
        final fn = procedure.fn as String Function();
        final ctx = RequestContext();

        final result = fn();
        final serialized = Serializers.instance.get<String>().serialize(result);
        return Response.ok(jsonEncode({"result": serialized}));
      })(request);
    default:
      return Response.notFound("Unknown procedure");
  }
});
