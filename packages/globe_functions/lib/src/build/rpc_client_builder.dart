import 'dart:convert';

import 'package:build/build.dart';
import 'package:glob/glob.dart';
import 'package:globe_functions/src/spec/serializer.dart';
import 'package:globe_functions/src/spec/sourced_function.dart';
import 'package:globe_functions/src/spec/sourced_type.dart';

class RpcClientBuilder implements Builder {
  final _imports = <Uri, String>{};
  var _importCounter = 0;

  String getImportPrefix(Uri? uri) {
    if (uri == null) return '';
    if (!_imports.containsKey(uri)) {
      _imports[uri] = 'i${_importCounter++}';
    }
    return _imports[uri]!;
  }

  // String getTypeName(SourcedType type) {
  //   if (type.uri == null) return type.type;
  //   return '${getImportPrefix(type.uri!())}.${type.type}';
  // }

  @override
  Future<void> build(BuildStep buildStep) async {}

  //   @override
  //   Future<void> build(BuildStep buildStep) async {
  //     final package = buildStep.inputId.package;

  //     final specs =
  //         await buildStep.findAssets(Glob('**/functions_spec.json')).toList();

  //     final json = await buildStep.readAsString(specs.first);

  //     final functions =
  //         (jsonDecode(json) as List<dynamic>)
  //             .map((e) => SourcedFunction.fromJson(e as Map<String, dynamic>))
  //             .toList();

  //     print(functions);

  //     // First process all functions to collect imports
  //     final pathGroups = <String, List<SourcedFunction>>{};
  //     for (final func in functions) {
  //       // Collect imports from return types
  //       if (func.returnType.uri != null) {
  //         getImportPrefix(func.returnType.uri);
  //       }

  //       // Collect imports from parameters
  //       for (final param in func.parameters) {
  //         if (param.type.uri != null) {
  //           getImportPrefix(param.type.uri);
  //         }
  //       }

  //       // Group functions as before
  //       final pathParts = func.uri.pathSegments.sublist(
  //         func.uri.pathSegments.indexOf('api') + 1,
  //       );
  //       pathParts[pathParts.length - 1] = pathParts.last.replaceAll('.dart', '');
  //       final path = pathParts.join('/');
  //       pathGroups[path] = [...(pathGroups[path] ?? []), func];
  //     }

  //     final content = StringBuffer('''
  // // ignore_for_file: implementation_imports, unnecessary_cast
  // // GENERATED CODE - DO NOT MODIFY BY HAND
  // // This code was generated by globe_functions

  // ''');

  //     // Add all required imports at the top
  //     content.writeln("import 'package:http/http.dart' as http;");
  //     content.writeln("import 'dart:convert';");
  //     content.writeln(
  //       "import 'package:globe_functions/src/build/serializer.dart' show Serializer, SerializerType;",
  //     );

  //     // Add all collected imports for types
  //     for (final entry in _imports.entries) {
  //       content.writeln("import '${entry.key}' as ${entry.value};");
  //     }
  //     content.writeln();

  //     // Write the base class
  //     content.writeln('''
  // abstract class RpcBaseClient {
  //   final String baseUrl;
  //   final http.Client client;
  //   final String path;

  //   RpcBaseClient({
  //     required this.baseUrl,
  //     required this.client,
  //     required this.path,
  //   });

  //   String get fullPath => '\$baseUrl/\$path';
  // }
  // ''');

  //     // Helper to check if a path has subpaths
  //     bool hasSubpath(String currentPath, String segment) {
  //       return pathGroups.keys.any((p) {
  //         if (!p.startsWith('$currentPath/')) return false;

  //         final remaining = p.substring(currentPath.length + 1);
  //         if (remaining.isEmpty) return false;

  //         return remaining.split('/')[0] == segment;
  //       });
  //     }

  //     // Generate segment classes from root to leaf
  //     final processedPaths = <String>{};
  //     for (final path in pathGroups.keys) {
  //       var currentPath = '';
  //       final segments = path.split('/');

  //       for (var i = 0; i < segments.length; i++) {
  //         currentPath = i == 0 ? segments[i] : '$currentPath/${segments[i]}';

  //         if (processedPaths.contains(currentPath)) continue;
  //         processedPaths.add(currentPath);

  //         final className = _generateClassName(segments.sublist(0, i + 1));

  //         // Check if this segment should be callable
  //         final parentPath = segments.sublist(0, i).join('/');
  //         final isCallable =
  //             pathGroups[parentPath]?.any(
  //               (func) => func.functionName == segments[i],
  //             ) ??
  //             false;

  //         content.writeln('''
  // class $className extends RpcBaseClient {
  //   $className({
  //     required super.baseUrl,
  //     required super.client,
  //   }) : super(path: '$currentPath');
  // ''');

  //         // Add call() method if this segment is callable
  //         if (isCallable) {
  //           content.writeln('''
  //   Future<String> call() async {
  //     final response = await client.post(
  //       Uri.parse(fullPath),
  //       body: jsonEncode({
  //         'positional': [],
  //         'named': {},
  //       }),
  //     );
  //     return response.body as String;
  //   }
  // ''');
  //         }

  //         // Add methods for this path level
  //         if (pathGroups.containsKey(currentPath)) {
  //           for (final func in pathGroups[currentPath]!) {
  //             final baseReturnType = getTypeName(func.returnType);
  //             final returnType = 'Future<$baseReturnType>';

  //             // Generate parameter list
  //             final parameters = <String>[];
  //             final positionalArgs = <String>[];
  //             final namedArgs = <String>[];
  //             final namedParams = <String>[];
  //             final optionalPositionals = <String>[];
  //             final paramTypes = <String, SourcedType>{};

  //             for (final param in func.parameters) {
  //               final paramType = getTypeName(param.type);
  //               if (param.isNamed) {
  //                 final required = param.isRequired ? 'required ' : '';
  //                 final defaultValue =
  //                     param.defaultValue != null
  //                         ? ' = ${param.defaultValue}'
  //                         : '';
  //                 namedParams.add(
  //                   '$required$paramType ${param.name}$defaultValue',
  //                 );
  //                 namedArgs.add("'${param.name}': ${param.name}");
  //                 paramTypes[param.name] = param.type; // Store with unquoted name
  //               } else if (param.isOptional) {
  //                 final defaultValue =
  //                     param.defaultValue != null
  //                         ? ' = ${param.defaultValue}'
  //                         : '';
  //                 optionalPositionals.add(
  //                   '$paramType ${param.name}$defaultValue',
  //                 );
  //                 positionalArgs.add(param.name);
  //                 paramTypes[param.name] =
  //                     param.type; // Store for optional params
  //               } else {
  //                 parameters.add('$paramType ${param.name}');
  //                 positionalArgs.add(param.name);
  //                 paramTypes[param.name] =
  //                     param.type; // Store for required params
  //               }
  //             }

  //             // Add optional positional parameters in a single set of brackets if there are any
  //             if (optionalPositionals.isNotEmpty) {
  //               parameters.add('[${optionalPositionals.join(', ')}]');
  //             }

  //             // Add named parameters inside a single set of braces if there are any
  //             if (namedParams.isNotEmpty) {
  //               parameters.add('{${namedParams.join(', ')}}');
  //             }

  //             if (!hasSubpath(currentPath, func.functionName)) {
  //               content.writeln('''
  //   $returnType ${func.functionName}(${parameters.join(', ')}) async {
  //     final response = await client.post(
  //       Uri.parse('\$fullPath/${func.functionName}'),
  //       body: jsonEncode({
  //         'positional': [${positionalArgs.map((arg) => 'Serializer.serialize(${_getSerializerType(paramTypes[arg]!)}, $arg)').join(', ')}],
  //         'named': {${namedArgs.map((arg) {
  //                 final name = arg.split(':')[0].substring(1).replaceAll("'", ''); // Remove quotes
  //                 final value = arg.split(':')[1].trim();
  //                 return "'$name': Serializer.serialize(${_getSerializerType(paramTypes[name]!)}, $value)";
  //               }).join(', ')}},
  //       }),
  //     );
  //     return ${_generateResponseHandler(func.returnType)};
  //   }
  // ''');
  //             }
  //           }
  //         }

  //         // Add getters for next level
  //         if (i < segments.length - 1) {
  //           final nextSegment = segments[i + 1];
  //           final nextClassName = _generateClassName(segments.sublist(0, i + 2));
  //           content.writeln('''
  //   $nextClassName get $nextSegment => $nextClassName(
  //     baseUrl: baseUrl,
  //     client: client,
  //   );
  // ''');
  //         }

  //         content.writeln('}');
  //         content.writeln();
  //       }
  //     }

  //     // Generate the main RpcClient class
  //     content.writeln('''
  // class RpcClient {
  //   final String baseUrl;
  //   final http.Client client;

  //   RpcClient(this.baseUrl, [http.Client? _client]) : client = _client ?? http.Client();
  // ''');

  //     // Add top-level getters
  //     final topLevelSegments =
  //         pathGroups.keys.map((p) => p.split('/').first).toSet();

  //     for (final segment in topLevelSegments) {
  //       final className = _generateClassName([segment]);
  //       content.writeln('''
  //   $className get $segment => $className(
  //     baseUrl: baseUrl,
  //     client: client,
  //   );''');
  //     }

  //     content.writeln('}');

  //     // Write the generated file
  //     await buildStep.writeAsString(
  //       AssetId(package, 'lib/rpc_client.g.dart'),
  //       content.toString(),
  //     );
  //   }

  //   String _generateClassName(List<String> segments) {
  //     return '${segments.map((s) => s[0].toUpperCase() + s.substring(1)).join()}Segment';
  //   }

  //   String _generateResponseHandler(SourcedType returnType) {
  //     final resultExtraction = 'jsonDecode(response.body)["result"]';

  //     if (returnType.serializerType == SerializerType.clazz) {
  //       final prefix = getImportPrefix(returnType.uri!());
  //       return '$prefix.${returnType.type}.fromJson($resultExtraction)';
  //     }

  //     return 'Serializer.fromJson($resultExtraction).deserialize() as ${returnType.type}';
  //   }

  //   String _getSerializerType(SourcedType type) {
  //     return 'SerializerType.${type.serializerType.name}';
  //   }

  @override
  Map<String, List<String>> get buildExtensions => {
    r'$lib$': ['rpc_client.g.dart'],
  };
}
